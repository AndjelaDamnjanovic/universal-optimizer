
import unittest
import unittest.mock as mocker
from unittest.mock import patch
from unittest.mock import mock_open

from bitstring import BitArray

from opt.single_objective.teaching.ones_count_problem.ones_count_problem import OnesCountProblem
from opt.single_objective.teaching.ones_count_problem.ones_count_problem_binary_int_solution import OnesCountProblemBinaryIntSolution
from uo.target_problem.target_problem import TargetProblem
from uo.target_problem.target_problem_void import TargetProblemVoid
from uo.target_solution.target_solution import TargetSolution


# Generated by CodiumAI

import unittest

class TestOnesCountProblemBinaryIntSolution(unittest.TestCase):

    # Create new instance of OnesCountProblemBinaryIntSolution with default parameters
    def test_create_new_instance_with_default_parameters(self):
        # Arrange

        # Act
        solution = OnesCountProblemBinaryIntSolution()

        # Assert
        self.assertEqual(solution.name, "OnesCountProblemBinaryIntSolution")
        self.assertIsNone(solution.fitness_value)
        self.assertIsNone(solution.fitness_values)
        self.assertIsNone(solution.objective_value)
        self.assertIsNone(solution.objective_values)
        self.assertFalse(solution.is_feasible)
        self.assertFalse(TargetSolution.evaluation_cache_cs.is_caching)
        self.assertEqual(TargetSolution.evaluation_cache_cs.max_cache_size, 0)
        self.assertFalse(TargetSolution.representation_distance_cache_cs.is_caching)
        self.assertEqual(TargetSolution.representation_distance_cache_cs.max_cache_size, 0)

    # Create new instance of OnesCountProblemBinaryIntSolution with custom parameters
    def test_create_new_instance_with_custom_parameters(self):
        # Arrange

        # Act
        solution = OnesCountProblemBinaryIntSolution(random_seed=123, evaluation_cache_is_used=True, 
                            evaluation_cache_max_size=100, distance_calculation_cache_is_used=True, 
                            distance_calculation_cache_max_size=200)

        # Assert
        self.assertEqual(solution.name, "OnesCountProblemBinaryIntSolution")
        self.assertIsNone(solution.fitness_value)
        self.assertIsNone(solution.fitness_values)
        self.assertIsNone(solution.objective_value)
        self.assertIsNone(solution.objective_values)
        self.assertFalse(solution.is_feasible)

    # Initialize solution randomly
    def test_initialize_solution_randomly(self):
        # Arrange
        problem_mock = mocker.MagicMock()
        type(problem_mock).name = mocker.PropertyMock(return_value='some_problem')
        type(problem_mock).dimension = mocker.PropertyMock(return_value=12)
        # Act
        solution = OnesCountProblemBinaryIntSolution()
        solution.init_random(problem_mock)
        # Assert
        self.assertIsNotNone(solution.representation)
        self.assertGreaterEqual(solution.representation, 0)
        self.assertLessEqual(solution.representation, 2**problem_mock.dimension - 1)

    # Initialize solution from representation
    def test_initialize_solution_from_representation(self):
        # Arrange
        problem_stub = mocker.MagicMock()
        type(problem_stub).name = mocker.PropertyMock(return_value='some_problem')
        type(problem_stub).dimension = mocker.PropertyMock(return_value=12)
        representation = 12345
        # Act
        solution = OnesCountProblemBinaryIntSolution()
        solution.init_from(representation, problem_stub)
        # Assert
        self.assertEqual(solution.representation, representation)

    # Calculate quality directly
    def test_calculate_quality_directly(self):
        # Arrange
        problem_stub = mocker.MagicMock()
        type(problem_stub).name = mocker.PropertyMock(return_value='some_problem')
        type(problem_stub).dimension = mocker.PropertyMock(return_value=12)
        representation = 12345
        # Act
        solution = OnesCountProblemBinaryIntSolution()
        quality = solution.calculate_quality_directly(representation, problem_stub)
        # Assert
        self.assertEqual(quality.fitness_value, representation.bit_count())
        self.assertIsNone(quality.fitness_values)
        self.assertEqual(quality.objective_value, representation.bit_count())
        self.assertIsNone(quality.objective_values)
        self.assertTrue(quality.is_feasible)

    # Obtain native representation from string representation
    def test_obtain_native_representation_from_string_representation(self):
        # Arrange
        representation_str = "101010"
        # Act
        solution = OnesCountProblemBinaryIntSolution()
        representation = solution.native_representation(representation_str)
        # Assert
        self.assertEqual(representation, int(representation_str, 2))

    # Create new instance of OnesCountProblemBinaryIntSolution with negative random seed
    def test_create_new_instance_with_negative_random_seed(self):
        # Arrange
        # Act
        solution = OnesCountProblemBinaryIntSolution(random_seed=-123)
        # Assert
        self.assertEqual(solution.random_seed, -123)

    # Create new instance of OnesCountProblemBinaryIntSolution with zero dimension
    def test_create_new_instance_with_zero_dimension(self):
        # Arrange
        problem_stub = mocker.MagicMock()
        type(problem_stub).name = mocker.PropertyMock(return_value='some_problem')
        type(problem_stub).dimension = mocker.PropertyMock(return_value=0)
        # Act
        solution = OnesCountProblemBinaryIntSolution()
        # Assert
        with self.assertRaises(ValueError):
            solution.init_random(problem_stub)

    # Create new instance of OnesCountProblemBinaryIntSolution with dimension greater than or equal to 32
    def test_create_new_instance_with_large_dimension(self):
        # Arrange
        problem_stub = mocker.MagicMock()
        type(problem_stub).name = mocker.PropertyMock(return_value='some_problem')
        type(problem_stub).dimension = mocker.PropertyMock(return_value=32)
        # Act
        solution = OnesCountProblemBinaryIntSolution()
        # Assert
        with self.assertRaises(ValueError):
            solution.init_random(problem_stub)

    # Initialize solution randomly with problem dimension set to None
    def test_initialize_solution_randomly_with_none_dimension(self):
        # Arrange
        problem_stub = mocker.MagicMock()
        type(problem_stub).name = mocker.PropertyMock(return_value='some_problem')
        type(problem_stub).dimension = mocker.PropertyMock(return_value=None)
        # Act
        solution = OnesCountProblemBinaryIntSolution()
        # Assert
        with self.assertRaises(ValueError):
            solution.init_random(problem_stub)

