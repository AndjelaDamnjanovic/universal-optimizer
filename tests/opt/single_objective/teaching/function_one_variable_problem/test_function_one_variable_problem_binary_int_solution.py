from pathlib import Path
directory = Path(__file__).resolve()
import sys
sys.path.append(directory.parent)

import unittest
import unittest.mock as mocker
from unittest.mock import patch
from unittest.mock import mock_open

from opt.single_objective.teaching.function_one_variable_problem.function_one_variable_problem import FunctionOneVariableProblem
from opt.single_objective.teaching.function_one_variable_problem.function_one_variable_problem import FunctionOneVariableProblemElements
from opt.single_objective.teaching.function_one_variable_problem.function_one_variable_problem_binary_int_solution import FunctionOneVariableProblemBinaryIntSolution

from uo.target_solution.target_solution import TargetSolution

# Generated by CodiumAI

import unittest

class TestFunctionOneVariableProblemBinaryIntSolution(unittest.TestCase):

    # Creating an instance of FunctionOneVariableProblemBinaryIntSolution with valid arguments should initialize the object correctly
    def test_valid_arguments_initialization(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

        self.assertEqual(solution.domain_from, domain_from)
        self.assertEqual(solution.domain_to, domain_to)
        self.assertEqual(solution.number_of_intervals, number_of_intervals)
        self.assertIsNone(solution.fitness_value)
        self.assertIsNone(solution.fitness_values)
        self.assertIsNone(solution.objective_value)
        self.assertIsNone(solution.objective_values)
        self.assertFalse(solution.is_feasible)
        self.assertFalse(TargetSolution.evaluation_cache_cs.is_caching)
        self.assertEqual(TargetSolution.evaluation_cache_cs.max_cache_size, 0)
        self.assertFalse(TargetSolution.representation_distance_cache_cs.is_caching)
        self.assertEqual(TargetSolution.representation_distance_cache_cs.max_cache_size, 0)

    # Calling copy() method on an instance of FunctionOneVariableProblemBinaryIntSolution should return a deep copy of the object
    def test_copy_method(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)
        copy_solution = solution.copy()

        self.assertIsNot(solution, copy_solution)
        self.assertEqual(solution.domain_from, copy_solution.domain_from)
        self.assertEqual(solution.domain_to, copy_solution.domain_to)
        self.assertEqual(solution.number_of_intervals, copy_solution.number_of_intervals)
        self.assertEqual(solution.representation, copy_solution.representation)

    # Calling domain_from getter on an instance of FunctionOneVariableProblemBinaryIntSolution should return the correct value
    def test_domain_from_getter(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

        self.assertEqual(solution.domain_from, domain_from)

    # Calling domain_to getter on an instance of FunctionOneVariableProblemBinaryIntSolution should return the correct value
    def test_domain_to_getter(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

        self.assertEqual(solution.domain_to, domain_to)

    # Calling number_of_intervals getter on an instance of FunctionOneVariableProblemBinaryIntSolution should return the correct value
    def test_number_of_intervals_getter(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

        self.assertEqual(solution.number_of_intervals, number_of_intervals)

    # Calling argument() method on an instance of FunctionOneVariableProblemBinaryIntSolution should return the correct value
    def test_argument_method(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)
        representation = 5

        expected_argument = domain_from + representation * (domain_to - domain_from) / number_of_intervals
        actual_argument = solution.argument(representation)

        self.assertEqual(actual_argument, expected_argument)

    # Creating an instance of FunctionOneVariableProblemBinaryIntSolution with domain_from equal to domain_to should raise a ValueError
    def test_domain_from_equal_to_domain_to(self):
        domain_from = 1.0
        domain_to = 1.0
        number_of_intervals = 10

        with self.assertRaises(ValueError):
            FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

    # Creating an instance of FunctionOneVariableProblemBinaryIntSolution with number_of_intervals equal to 0 should raise a ValueError
    def test_number_of_intervals_equal_to_zero(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 0

        with self.assertRaises(ValueError):
            FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

    # Calling __make_to_be_feasible_helper__() method on an instance of FunctionOneVariableProblemBinaryIntSolution with representation greater than number_of_intervals should set representation to number_of_intervals
    def test_make_to_be_feasible_helper_greater_than_number_of_intervals(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)
        solution.representation = 15

        solution.__make_to_be_feasible_helper__(None)

        self.assertEqual(solution.representation, number_of_intervals)

    # Calling __make_to_be_feasible_helper__() method on an instance of FunctionOneVariableProblemBinaryIntSolution with representation less than 0 should set representation to 0
    def test_make_to_be_feasible_helper_less_than_zero(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)
        solution.representation = -5

        solution.__make_to_be_feasible_helper__(None)

        self.assertEqual(solution.representation, 0)

    # Calling native_representation() method on an instance of FunctionOneVariableProblemBinaryIntSolution with a string containing non-binary characters should raise a ValueError
    def test_native_representation_non_binary_characters(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)
        representation_str = "12345"

        with self.assertRaises(ValueError):
            solution.native_representation(representation_str)


class Test__Init__(unittest.TestCase):

    # Initializes the object with valid input parameters.
    def test_valid_input_parameters(self):
        # Arrange
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        # Act
        obj = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

        # Assert
        self.assertEqual(obj.domain_from, domain_from)
        self.assertEqual(obj.domain_to, domain_to)
        self.assertEqual(obj.number_of_intervals, number_of_intervals)

    # Initializes the object with the minimum possible values for domain_from, domain_to, and number_of_intervals.
    def test_minimum_values(self):
        # Arrange
        domain_from = sys.float_info.min
        domain_to = sys.float_info.min
        number_of_intervals = 1

        # Act & Assert
        with self.assertRaises(ValueError):
            FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

    # Initializes the object with the maximum possible values for domain_from, domain_to, and number_of_intervals.
    def test_maximum_values(self):
        # Arrange
        domain_from = sys.float_info.max
        domain_to = sys.float_info.max
        number_of_intervals = sys.maxsize

        # Act & Assert
        with self.assertRaises(ValueError):
            FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

    # Initializes the object with the non-integer number_of_intervals.
    def test_non_integer_number_of_intervals(self):
        # Arrange
        domain_from = 0
        domain_to = 10
        number_of_intervals = 5.6

        # Act & Assert
        with self.assertRaises(ValueError):
            FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)



    # Initializes the object with domain_from and domain_to as integers.
    def test_integer_domain(self):
        # Arrange
        domain_from = 0
        domain_to = 10
        number_of_intervals = 5

        # Act
        obj = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

        # Assert
        self.assertEqual(obj.domain_from, float(domain_from))
        self.assertEqual(obj.domain_to, float(domain_to))
        self.assertEqual(obj.number_of_intervals, number_of_intervals)

    # Initializes the object with domain_from and domain_to as floats.
    def test_float_domain(self):
        # Arrange
        domain_from = 0.0
        domain_to = 10.0
        number_of_intervals = 5

        # Act
        obj = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

        # Assert
        self.assertEqual(obj.domain_from, domain_from)
        self.assertEqual(obj.domain_to, domain_to)
        self.assertEqual(obj.number_of_intervals, number_of_intervals)


class Test__MakeToBeFeasibleHelper__(unittest.TestCase):

    # If the representation is within the range of [0, number_of_intervals], the representation should not be changed.
    def test_representation_within_range(self):
        problem = FunctionOneVariableProblem("x**2", 0, 10)
        solution = FunctionOneVariableProblemBinaryIntSolution(0, 10, 5)
        solution.representation = 3
        solution.__make_to_be_feasible_helper__(problem)
        self.assertEqual(solution.representation, 3)

    # If the representation is equal to number_of_intervals, the representation should be set to number_of_intervals.
    def test_representation_equal_to_number_of_intervals(self):
        problem = FunctionOneVariableProblem("x**2", 0, 10)
        solution = FunctionOneVariableProblemBinaryIntSolution(0, 10, 5)
        solution.representation = 5
        solution.__make_to_be_feasible_helper__(problem)
        self.assertEqual(solution.representation, 5)

    # If the representation is negative, the representation should be set to 0.
    def test_representation_negative(self):
        problem = FunctionOneVariableProblem("x**2", 0, 10)
        solution = FunctionOneVariableProblemBinaryIntSolution(0, 10, 5)
        solution.representation = -2
        solution.__make_to_be_feasible_helper__(problem)
        self.assertEqual(solution.representation, 0)


class TestInitRandom(unittest.TestCase):

    # When called, 'init_random' should set the 'representation' attribute of the 'FunctionOneVariableProblemBinaryIntSolution' instance to a random integer between 0 and 'number_of_intervals'
    def test_set_representation_to_random_integer(self):
        problem = FunctionOneVariableProblem("x**2", 0, 10)
        solution = FunctionOneVariableProblemBinaryIntSolution(0, 10, 5)
        solution.init_random(problem)
        self.assertIsInstance(solution.representation, int)
        self.assertGreaterEqual(solution.representation, 0)
        self.assertLessEqual(solution.representation, solution.number_of_intervals)

    # If the 'representation' attribute is already set, calling 'init_random' should overwrite it with a new random integer between 0 and 'number_of_intervals'
    def test_overwrite_representation_with_random_integer(self):
        problem = FunctionOneVariableProblem("x**2", 0, 10)
        solution = FunctionOneVariableProblemBinaryIntSolution(0, 10, 5)
        solution.representation = 3
        solution.init_random(problem)
        self.assertIsInstance(solution.representation, int)
        self.assertGreaterEqual(solution.representation, 0)
        self.assertLessEqual(solution.representation, solution.number_of_intervals)
