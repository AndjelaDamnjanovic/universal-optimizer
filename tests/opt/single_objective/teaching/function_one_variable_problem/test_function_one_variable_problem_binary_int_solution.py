from pathlib import Path
directory = Path(__file__).resolve()
import sys
sys.path.append(directory.parent)

import unittest
import unittest.mock as mocker
from unittest.mock import patch
from unittest.mock import mock_open

from opt.single_objective.teaching.function_one_variable_problem.function_one_variable_problem import FunctionOneVariableProblem
from opt.single_objective.teaching.function_one_variable_problem.function_one_variable_problem import FunctionOneVariableProblemElements
from opt.single_objective.teaching.function_one_variable_problem.function_one_variable_problem_binary_int_solution import FunctionOneVariableProblemBinaryIntSolution

from uo.target_solution.target_solution import TargetSolution

# Generated by CodiumAI

import unittest

class TestFunctionOneVariableProblemBinaryIntSolution(unittest.TestCase):

    # Creating an instance of FunctionOneVariableProblemBinaryIntSolution with valid arguments should initialize the object correctly
    def test_valid_arguments_initialization(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

        self.assertEqual(solution.domain_from, domain_from)
        self.assertEqual(solution.domain_to, domain_to)
        self.assertEqual(solution.number_of_intervals, number_of_intervals)
        self.assertIsNone(solution.fitness_value)
        self.assertIsNone(solution.fitness_values)
        self.assertIsNone(solution.objective_value)
        self.assertIsNone(solution.objective_values)
        self.assertFalse(solution.is_feasible)
        self.assertFalse(TargetSolution.evaluation_cache_cs.is_caching)
        self.assertEqual(TargetSolution.evaluation_cache_cs.max_cache_size, 0)
        self.assertFalse(TargetSolution.representation_distance_cache_cs.is_caching)
        self.assertEqual(TargetSolution.representation_distance_cache_cs.max_cache_size, 0)

    # Calling copy() method on an instance of FunctionOneVariableProblemBinaryIntSolution should return a deep copy of the object
    def test_copy_method(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)
        copy_solution = solution.copy()

        self.assertIsNot(solution, copy_solution)
        self.assertEqual(solution.domain_from, copy_solution.domain_from)
        self.assertEqual(solution.domain_to, copy_solution.domain_to)
        self.assertEqual(solution.number_of_intervals, copy_solution.number_of_intervals)
        self.assertEqual(solution.representation, copy_solution.representation)

    # Calling domain_from getter on an instance of FunctionOneVariableProblemBinaryIntSolution should return the correct value
    def test_domain_from_getter(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

        self.assertEqual(solution.domain_from, domain_from)

    # Calling domain_to getter on an instance of FunctionOneVariableProblemBinaryIntSolution should return the correct value
    def test_domain_to_getter(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

        self.assertEqual(solution.domain_to, domain_to)

    # Calling number_of_intervals getter on an instance of FunctionOneVariableProblemBinaryIntSolution should return the correct value
    def test_number_of_intervals_getter(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

        self.assertEqual(solution.number_of_intervals, number_of_intervals)

    # Calling argument() method on an instance of FunctionOneVariableProblemBinaryIntSolution should return the correct value
    def test_argument_method(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)
        representation = 5

        expected_argument = domain_from + representation * (domain_to - domain_from) / number_of_intervals
        actual_argument = solution.argument(representation)

        self.assertEqual(actual_argument, expected_argument)

    # Creating an instance of FunctionOneVariableProblemBinaryIntSolution with domain_from equal to domain_to should raise a ValueError
    def test_domain_from_equal_to_domain_to(self):
        domain_from = 1.0
        domain_to = 1.0
        number_of_intervals = 10

        with self.assertRaises(ValueError):
            FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

    # Creating an instance of FunctionOneVariableProblemBinaryIntSolution with number_of_intervals equal to 0 should raise a ValueError
    def test_number_of_intervals_equal_to_zero(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 0

        with self.assertRaises(ValueError):
            FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)

    # Calling __make_to_be_feasible_helper__() method on an instance of FunctionOneVariableProblemBinaryIntSolution with representation greater than number_of_intervals should set representation to number_of_intervals
    def test_make_to_be_feasible_helper_greater_than_number_of_intervals(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)
        solution.representation = 15

        solution.__make_to_be_feasible_helper__(None)

        self.assertEqual(solution.representation, number_of_intervals)

    # Calling __make_to_be_feasible_helper__() method on an instance of FunctionOneVariableProblemBinaryIntSolution with representation less than 0 should set representation to 0
    def test_make_to_be_feasible_helper_less_than_zero(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)
        solution.representation = -5

        solution.__make_to_be_feasible_helper__(None)

        self.assertEqual(solution.representation, 0)

    # Calling native_representation() method on an instance of FunctionOneVariableProblemBinaryIntSolution with a string containing non-binary characters should raise a ValueError
    def test_native_representation_non_binary_characters(self):
        domain_from = 0.0
        domain_to = 1.0
        number_of_intervals = 10

        solution = FunctionOneVariableProblemBinaryIntSolution(domain_from, domain_to, number_of_intervals)
        representation_str = "12345"

        with self.assertRaises(ValueError):
            solution.native_representation(representation_str)